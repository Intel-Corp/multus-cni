os: linux
language: go
# see https://docs.travis-ci.com/user/reference/overview/#Virtualization-environments
# for the detail
# sudo: requried
dist: bionic

services:
  - docker

go:
  - 1.13.x

env:
  global:
    - GO111MODULE=on
    - REGISTRY_USER=${REGISTRY_USER:-nfvpe}
    - REGISTRY_PASS=${REGISTRY_PASS}
    - REPOSITORY_NAME=${REPOSITORY_NAME}
    - REPOSITORY_USER=${REPOSITORY_USER}
    - DOCKER_CLI_EXPERIMENTAL="enabled"
    - secure: "${REGISTRY_SECURE}"
  jobs:
    - TARGET=amd64
    - TARGET=ppc64le

before_install:
  - if [ "${REPOSITORY_NAME}" = "" ]; then export REPOSITORY_NAME=multus; fi
  - sudo apt-get update -qq
  - go get github.com/mattn/goveralls

install:
  - go get -u golang.org/x/lint/golint
  # Download kind & deps
  - curl -Lo ./kind "https://github.com/kubernetes-sigs/kind/releases/download/v0.7.0/kind-$(uname)-amd64"
  - chmod +x ./kind
  - sudo mv ./kind /usr/bin
  - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
  - chmod +x ./kubectl
  - sudo mv ./kubectl /usr/bin
  # Spin up kind
  - kind create cluster --config e2e-tests/config-3node.yml 
  - export KUBECONFIG=~/.kube/config
  # Download centos tools
  - docker pull centos/tools:latest
  - kind load docker-image centos/tools:latest
  # Install koko
  - curl -LO https://github.com/redhat-nfvpe/koko/releases/download/v0.82/koko_0.82_linux_amd64
  - chmod +x koko_0.82_linux_amd64
  # Create veth interface between kind-woker and kind-worker2
  - sudo ./koko_0.82_linux_amd64 -d kind-worker,eth1 -d kind-worker2,eth1
  # Verify that kind is running
  - kubectl get nodes
  # Install flannel
  - curl https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml -o flannel.yml
  - kubectl create -f flannel.yml
  # Install default CNI plugins
  - kubectl create -f images/cni-install.yml

before_script:
  # Make gopath... to run golint/go fmt/go vet
  # Suppress golint for fixing lint later.
  - golint ./... | grep -v vendor | grep -v ALL_CAPS | xargs -r false
  - go fmt ./...
  - go vet ./...
#  - gocyclo -over 15 ./multus

script:
  - GOARCH="${TARGET}" ./build
  - |
    if [ "${TARGET}" == "amd64" ]; then
      # Run the test suite
      sudo env PATH=${PATH} ./test.sh
      goveralls -coverprofile=coverage.out -service=travis-ci
    fi

  - |
    # Test building the docker images
    if [ "${TARGET}" == "amd64" ]; then
      docker build -t ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 .
      docker build -t multus/multus-cni:latest .
      docker build -t ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le -f Dockerfile.ppc64le .
      docker build -t ${REPOSITORY_USER}/${REPOSITORY_NAME}-origin:latest -f Dockerfile.openshift .
    fi

  - |
    # End to end test with KIND
    if [ "${TARGET}" == "amd64" ]; then
      kind load docker-image multus/multus-cni:latest
      cp images/multus-daemonset.yml images/multus-test-daemonset.yml
      sed -ie '0,/        image:.*/ s|        image:.*|        image: multus/multus-cni:latest|' images/multus-test-daemonset.yml
      sed -ie '/image: multus/ a\\        imagePullPolicy: Never' images/multus-test-daemonset.yml
      cat images/multus-test-daemonset.yml
      kubectl create -f images/multus-test-daemonset.yml
      # Wait for the multus pod to become ready.
      kubectl describe pod $(kubectl get pods -n kube-system | grep multus | awk '{print $1}') -n kube-system
      i="0"
      while [ $i -le 120 ]; do
        pods=$(kubectl get pods -n kube-system)
        if echo "$pods" | grep -Piq "multus.+running"; then
          echo "Detected Multus pod running..."
          break
        else
          echo "Multus not running yet..."
          sleep 1
        fi
        i=$[$i+1]
      done
      if [ $i -ge 120 ]; then
        echo "Too long to wait for Multus pod..."
        exit 1
      fi
      kubectl describe pod $(kubectl get pods -n kube-system | grep multus | awk '{print $1}') -n kube-system
      kubectl get pods --all-namespaces
      kubectl logs $(kubectl get pods -n kube-system | grep multus | awk '{print $1}') -n kube-system
      kubectl create -f e2e-tests/centos-macvlan.yml
      # Wait for the centos pods to become ready
      i="0"
      while [ $i -le 240 ]; do
        pods=$(kubectl get pods)
        if echo "$pods" | grep -Piq "centos.worker1.+running"; then
          echo "Detected centos pod running..."
          break
        else
          echo "Multus not running yet..."
          sleep 1
        fi
        i=$[$i+1]
      done
      kubectl describe pod centos-worker1
      if [ $i -ge 240 ]; then
        echo "Too long to wait for Centos pod..."
        exit 1
      fi
      kubectl exec -it centos-worker1 -- ip a | grep net1
      kubectl exec -it centos-worker2 -- ip a | grep net1
      kubectl exec -it centos-worker2 -- ping -c5 10.1.1.11
    fi

deploy:
  # Release on versioned tag (e.g. v1.0)
  - provider: script
    #cleanup: false
    script: curl -sL https://git.io/goreleaser
    on:
      tags: true
      all_branches: true
      condition: "$TARGET = amd64 && $TRAVIS_TAG =~ ^v[0-9].*$ && ! -z $GITHUB_TOKEN && $TRAVIS_OS_NAME = linux"
  # Push images to Dockerhub on tag
  - provider: script
    cleanup: false
    script: >
      bash -c '
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-amd64;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:$TRAVIS_TAG;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-ppc64le;
      docker login -u "$REGISTRY_USER" -p "$REGISTRY_PASS"; 
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-amd64;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-ppc64le;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:$TRAVIS_TAG;
      export DOCKER_CLI_EXPERIMENTAL="enabled";
      docker manifest create ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 --arch amd64;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le --arch ppc64le;
      docker manifest push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest;
      docker manifest create ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-ppc64le;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-amd64 --arch amd64;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable-ppc64le --arch ppc64le;
      docker manifest push ${REPOSITORY_USER}/${REPOSITORY_NAME}:stable;
      echo done'
    on:
      tags: true
      all_branches: true
      condition: "$TRAVIS_TAG =~ ^v[0-9].*$ && -n $REGISTRY_USER && -n $REGISTRY_PASS && -n $REPOSITORY_NAME"
  # Push images to Dockerhub on merge to master
  - provider: script
    on:
      branch: master
      condition: "-n $REGISTRY_USER && -n $REGISTRY_PASS && -n $REPOSITORY_NAME"
    script: >
      bash -c '
      docker tag ${REPOSITORY_USER}/:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-amd64;
      docker tag ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-ppc64le;
      docker login -u "$REGISTRY_USER" -p "$REGISTRY_PASS";
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-amd64;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-ppc64le;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64;
      docker push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le;
      docker manifest create ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-ppc64le;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-amd64 --arch amd64;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot-ppc64le --arch ppc64le;
      docker manifest push ${REPOSITORY_USER}/${REPOSITORY_NAME}:snapshot;
      docker manifest create ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-amd64 --arch amd64;
      docker manifest annotate ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest-ppc64le --arch ppc64le;
      docker manifest push ${REPOSITORY_USER}/${REPOSITORY_NAME}:latest;
      echo done'
